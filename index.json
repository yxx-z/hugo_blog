[{"categories":["网络"],"content":"获取天翼网关超级密码 ","date":"2023-04-22","objectID":"/dianxing/:0:0","tags":["网关"],"title":"获取天翼网关超级管理员密码","uri":"/dianxing/"},{"categories":["网络"],"content":"前言 因为自己在家用nas搭建了个影音系统。但是由于运营商不给ipv4 只能退而求其次使用ipv6用来外网访问。但是在老家中的电信宽带没有开启ipv6 无法观看。 ","date":"2023-04-22","objectID":"/dianxing/:1:0","tags":["网关"],"title":"获取天翼网关超级管理员密码","uri":"/dianxing/"},{"categories":["网络"],"content":"获取超级管理员密码 天翼网关上贴的密码，默认是管理员，只有更改密码名称等低级权限。如果要把网关改成桥接模式，只能用超级管理员账号。但是问了宽带小哥，也不清楚。只能自己动手破机了。 神秘代码 http://192.168.1.1:80/telandftpcfg.cmd?action=add\u0026telusername=光猫用户名\u0026telpwd=密码\u0026telport=23\u0026telenable=1\u0026ftpusername=光猫用户名\u0026ftppwd=密码\u0026ftpport=21\u0026ftpenable=1\u0026sessionKey=[你的当次浏览器sessionKey] 注：这里的光猫用户名 是天翼网关后面贴的默认用户名，密码也是。 sessionKey获取：用天翼网关默认的账号登录后，鼠标右键选择查看源码。在源码中搜索sessionKey，后面会有对应的随机数。每次登录这个sessionKey对应的随机数都不一样。先不要关闭当前登录的网关系统窗口。另起一个窗口。然后把神秘代码复制进去。回车访问。 然后会得到telent的账号密码以及端口 用telent软件或者黑窗口访问 telnet 192.168.1.1 端口 然后会让你输入用户名和密码。正常是网关后面贴的默认账号密码。然后通过下面命令获取超级管理员密码 telecomadmin get 密码就会出现。 ","date":"2023-04-22","objectID":"/dianxing/:2:0","tags":["网关"],"title":"获取天翼网关超级管理员密码","uri":"/dianxing/"},{"categories":["java"],"content":"在使用Springboot时，通常很多信息都是在application.yml中直接明文配置的，比如数据库链接信息，redis链接信息等等。但是这样是不安全的。 ","date":"2023-03-30","objectID":"/configenc/:0:0","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"前言 开发或者工作中，很多配置都是以明文的方式放在yml文件里，但是这样是不符合安全规范的。在公司的要求下，配置文件中敏感信息需要加密。 ","date":"2023-03-30","objectID":"/configenc/:1:0","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"解决 ","date":"2023-03-30","objectID":"/configenc/:2:0","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"引入pom依赖 \u003c!-- jasypt --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.ulisesbocchio\u003c/groupId\u003e \u003cartifactId\u003ejasypt-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.0.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2023-03-30","objectID":"/configenc/:2:1","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"yml文件中配置加密钥匙 jasypt:encryptor:password:pwdalgorithm:PBEWithMD5AndDESiv-generator-classname:org.jasypt.iv.NoIvGenerator 注：pwd为密钥，自己随意配置 这里的配置是在开发时候，毕竟如果上线的话密钥放在yml里 加不加密一个样。 线上启动的方式后面说 ","date":"2023-03-30","objectID":"/configenc/:2:2","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"加密敏感数据 未加密前mysql部分配置 spring:#定义数据源datasource:url:jdbc:mysql://localhost:3306/test?useSSL=false\u0026useUnicode=true\u0026characterEncoding=UTF-8\u0026serverTimezone=GMT%2B8\u0026zeroDateTimeBehavior=convertToNull 开始加密 这里在单元测试里运行加密 @Autowired private StringEncryptor encryptor; @Test void encrypt(){ System.out.println(\"mysqlUrl: \" + encryptor.encrypt(\"jdbc:mysql://localhost:3306/test?useSSL=false\u0026useUnicode=true\u0026characterEncoding=UTF-8\u0026serverTimezone=GMT%2B8\u0026zeroDateTimeBehavior=convertToNull\")); } 运行单元测试结果 mysqlUrl: ROeydT7oNHA3CCU+WPpgVc8wNdGS2flt/hlt3ot6YlXadrF4TP4P3ehdP+jMpnmW0XscNR2LYQzlIW9sQRsmEp62Mwk86afyLl3WiJr+aYijHuVIBeetc9uvGgCNcA5Jjr0stCfXgU5pRAbyaD+OK6Hz08iByAD0gq3PoOGo4H6yhSL3+HKo0a0bczgAJSIvxT+xr04chuIu/1QiFODNke+s6lGY+UEucAZikq0UUI4= ","date":"2023-03-30","objectID":"/configenc/:2:3","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"将加密后数据配置到yml文件中 规则：ENC(加密后的数据) 例： spring:#定义数据源datasource:url:ENC(ROeydT7oNHA3CCU+WPpgVc8wNdGS2flt/hlt3ot6YlXadrF4TP4P3ehdP+jMpnmW0XscNR2LYQzlIW9sQRsmEp62Mwk86afyLl3WiJr+aYijHuVIBeetc9uvGgCNcA5Jjr0stCfXgU5pRAbyaD+OK6Hz08iByAD0gq3PoOGo4H6yhSL3+HKo0a0bczgAJSIvxT+xr04chuIu/1QiFODNke+s6lGY+UEucAZikq0UUI4=) 启动项目，调用接口发现能够正常获取数据库中数据 表明加解密成功 ","date":"2023-03-30","objectID":"/configenc/:2:4","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"线上使用 前面是将密钥配置在yml文件中，在项目上生产的时候这样肯定不行，毕竟把密钥放里面和没加密没有区别。 现在将上面配置的密钥删除 jasypt:encryptor:password:pwd #上线时候删除这一行algorithm:PBEWithMD5AndDESiv-generator-classname:org.jasypt.iv.NoIvGenerator 删除以上部分中的 password。其它保留。加密过的数据也保留，例如mysql的url ENC(….)部分保持不变。 然后在启动jar包的时候增加一下命令 -Djasypt.encryptor.password=pwd java -jar -Djasypt.encryptor.password=pwd XXX-xxxx.jar ","date":"2023-03-30","objectID":"/configenc/:2:5","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"结束 完事，划水 ","date":"2023-03-30","objectID":"/configenc/:3:0","tags":["加密"],"title":"SpringBoot配置文件yml内容加密","uri":"/configenc/"},{"categories":["java"],"content":"通用手动分页工具类,返回mybatis-plus中IPage\u003cT\u003e格式。 ","date":"2023-03-25","objectID":"/pageutil/:0:0","tags":["分页"],"title":"手动分页工具类","uri":"/pageutil/"},{"categories":["java"],"content":"前言 在开发中，有时会遇到手动分页的情况。现在用mybatis-plus比较多。为了给前端分页格式统一。在手动分页的时候也返回mybatis-plus的分页格式。 ","date":"2023-03-25","objectID":"/pageutil/:1:0","tags":["分页"],"title":"手动分页工具类","uri":"/pageutil/"},{"categories":["java"],"content":"手动分页通用工具类 pageUtils package com.yunjia.eduction.utils; import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import java.util.List; /** * @author yxx * @since 2023-03-25 14:13 */ public class PageUtils { /** * 手动分页 * * @param list 分页前的集合 * @param pageNo 页码 * @param pageSize 页数 * @return 分页后的集合 */ public static \u003cT\u003e IPage\u003cT\u003e pageList(List\u003cT\u003e list, int pageNo, int pageSize) { //计算总页数 int page = list.size() % pageSize == 0 ? list.size() / pageSize : list.size() / pageSize + 1; //兼容性分页参数错误 pageNo = pageNo \u003c= 0 ? 1 : pageNo; pageNo = Math.min(pageNo, page); // 开始索引 int begin; // 结束索引 int end; if (pageNo != page) { begin = (pageNo - 1) * pageSize; end = begin + pageSize; } else { begin = (pageNo - 1) * pageSize; end = list.size(); } IPage\u003cT\u003e pg = new Page\u003c\u003e(); pg.setTotal(list.size()); pg.setCurrent(pageNo); pg.setSize(pageSize); return pg.setRecords(list.subList(begin, end)); } } ","date":"2023-03-25","objectID":"/pageutil/:2:0","tags":["分页"],"title":"手动分页工具类","uri":"/pageutil/"},{"categories":["java"],"content":"开发中经常遇到树状结构，每次都要写比较麻烦。这里写了一个工具类简化其中的步骤 这里用了java8函数式编程特性 话不多说，上代码 ","date":"2023-03-10","objectID":"/tree/:0:0","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["java"],"content":"菜单类 import com.baomidou.mybatisplus.annotation.*; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.io.Serializable; import java.util.List; /** * @author yxx * @since 2023-03-07 14:46 */ @Data @TableName(\"ee_menu\") public class Menu implements Serializable { /** * 主键 */ @ApiModelProperty(value = \"业务主键\") @TableId(type = IdType.AUTO) private Integer id; /** * 父id */ @ApiModelProperty(value = \"父id\") private Integer parentId; /** * 菜单标识 */ @ApiModelProperty(value = \"菜单标识\") private String menuCode; /** * 菜单名称 */ @ApiModelProperty(value = \"菜单名称\") private String menuName; /** * 菜单类型: 1- 管理系统; 2- 子系统 */ @ApiModelProperty(value = \"菜单类型: 1- 管理系统; 2- 子系统\") private Integer menuType; /** * 是否删除: 0- 否; 1- 是 */ @ApiModelProperty(value = \"是否删除: 0- 否; 1- 是\") @TableLogic private Integer isDelete; /** * 子菜单集合 */ @TableField(exist = false) private List\u003cMenu\u003e children; } ","date":"2023-03-10","objectID":"/tree/:0:1","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["java"],"content":"工具类 package com.yunjia.eduction.utils.tree; import java.util.*; import java.util.function.BiConsumer; import java.util.function.Function; import java.util.stream.Collectors; /** * @author yxx * @apiNote 通用树形工具类 * @since 2023-03-11 14:22 */ public class TreeUtil { /*** * 构建树 * * @param listData 需要构建的结果集 * @param parentKeyFunction 父节点id * @param keyFunction 主键 * @param setChildrenFunction 子集 * @param rootParentValue 父节点的值 0就填0 null就填null * @return java.util.List\u003cT\u003e */ public static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue) { return buildTree(listData, parentKeyFunction, keyFunction, setChildrenFunction, rootParentValue, null, null); } /*** * 构建树，并且对结果集做升序处理 * * @param listData 需要构建的结构集 * @param parentKeyFunction 父节点 * @param keyFunction 主键 * @param setChildrenFunction 子集 * @param rootParentValue 父节点的值 * @param sortFunction 排序字段 * @return java.util.List\u003cT\u003e */ public static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildAscTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue, Function\u003cT, ? extends Comparable\u003e sortFunction) { List\u003cT\u003e resultList = buildTree(listData, parentKeyFunction, keyFunction, setChildrenFunction, rootParentValue, sortFunction, 0); return sortList(resultList, sortFunction, 0); } /*** * 构建树，并且对结果集做降序处理 * * @param listData 需要构建的结构集 * @param parentKeyFunction 父节点 * @param keyFunction 主键 * @param setChildrenFunction 子集 * @param rootParentValue 父节点的值 * @param sortFunction 排序字段 * @return java.util.List\u003cT\u003e */ public static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildDescTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue, Function\u003cT, ? extends Comparable\u003e sortFunction) { List\u003cT\u003e resultList = buildTree(listData, parentKeyFunction, keyFunction, setChildrenFunction, rootParentValue, sortFunction, 1); return sortList(resultList, sortFunction, 1); } private static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue, Function\u003cT, ? extends Comparable\u003e sortFunction, Integer sortedFlag) { // 筛选出根节点 Map\u003cComparable, T\u003e rootKeyMap = new HashMap\u003c\u003e(); // 所有的节点 Map\u003cComparable, T\u003e allKeyMap = new HashMap\u003c\u003e(); // 存id:List\u003cChildrenId\u003e Map\u003cComparable, List\u003cComparable\u003e\u003e keyParentKeyMap = new HashMap\u003c\u003e(); for (T t : listData) { Comparable key = keyFunction.apply(t); Comparable parentKey = parentKeyFunction.apply(t); // 如果根节点标识为null，值也为null，表示为根节点 if (rootParentValue == null \u0026\u0026 parentKeyFunction.apply(t) == null) { rootKeyMap.put(key, t); } // 根节点标识有值，值相同表示为根节点 if (rootParentValue != null \u0026\u0026 parentKeyFunction.apply(t).compareTo(rootParentValue) == 0) { rootKeyMap.put(key, t); } allKeyMap.put(key, t); if (parentKey != null) { List\u003cComparable\u003e children = keyParentKeyMap.getOrDefault(parentKey, new ArrayList\u003c\u003e()); children.add(key); keyParentKeyMap.put(parentKey, children); } } List\u003cT\u003e returnList = new ArrayList\u003c\u003e(); // 封装根节点数据 for (Comparable comparable : rootKeyMap.keySet()) { setChildren(comparable, returnList, allKeyMap, keyParentKeyMap, setChildrenFunction, sortFunction, sortedFlag); } return returnList; } private static \u003cT\u003e void setChildren(Comparable comparable, List\u003cT\u003e childrenList, Map\u003cComparable, T\u003e childrenKeyMap, Map\u003cComparable, List\u003cComparable\u003e\u003e keyParentKeyMap, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, Function\u003cT, ? extends Comparable\u003e sortFunction, Integer sortedFlag) { T t = childrenKeyMap.get(comparable); if (keyParentKeyMap.containsKey(comparable)) { List\u003cT\u003e subChildrenList = new ArrayList\u003c\u003e(); List\u003cComparable\u003e childrenComparable = keyParentKeyMap.get(comparable); for (Comparable c : childrenComparable","date":"2023-03-10","objectID":"/tree/:0:2","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["java"],"content":"使用 @Override public List\u003cMenu\u003e treeMenu(List\u003cMenu\u003e menuList) { /* * 构建树 * * @param listData 需要构建的结果集 这里是menuList * @param parentKeyFunction 父节点 这里是parentId * @param keyFunction 主键 这里是id * @param setChildrenFunction 子集 这里是children * @param rootParentValue 父节点的值 这里null * @return java.util.List\u003cT\u003e */ return TreeUtil.buildTree(menuList, Menu::getParentId, Menu::getId, Menu::setChildren, null); } ","date":"2023-03-10","objectID":"/tree/:0:3","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["基础"],"content":"新的篇章，新的开始 经历了国内云服务器被封导致以前的博客全部丢失，现在转战静态博客，部署github上 ","date":"2023-03-09","objectID":"/first/:0:0","tags":["基础"],"title":"开篇!","uri":"/first/"}]