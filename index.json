[{"categories":["java"],"content":"开发中经常遇到树状结构，每次都要写比较麻烦。这里写了一个工具类简化其中的步骤 这里用了java8函数式编程特性 话不多说，上代码 ","date":"2023-03-10","objectID":"/tree/:0:0","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["java"],"content":"菜单类 import com.baomidou.mybatisplus.annotation.*; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.io.Serializable; import java.util.List; /** * @author yxx * @since 2023-03-07 14:46 */ @Data @TableName(\"ee_menu\") public class Menu implements Serializable { /** * 主键 */ @ApiModelProperty(value = \"业务主键\") @TableId(type = IdType.AUTO) private Integer id; /** * 父id */ @ApiModelProperty(value = \"父id\") private Integer parentId; /** * 菜单标识 */ @ApiModelProperty(value = \"菜单标识\") private String menuCode; /** * 菜单名称 */ @ApiModelProperty(value = \"菜单名称\") private String menuName; /** * 菜单类型: 1- 管理系统; 2- 子系统 */ @ApiModelProperty(value = \"菜单类型: 1- 管理系统; 2- 子系统\") private Integer menuType; /** * 是否删除: 0- 否; 1- 是 */ @ApiModelProperty(value = \"是否删除: 0- 否; 1- 是\") @TableLogic private Integer isDelete; /** * 子菜单集合 */ @TableField(exist = false) private List\u003cMenu\u003e children; } ","date":"2023-03-10","objectID":"/tree/:0:1","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["java"],"content":"工具类 package com.yunjia.eduction.utils.tree; import java.util.*; import java.util.function.BiConsumer; import java.util.function.Function; import java.util.stream.Collectors; /** * @author yxx * @apiNote 通用树形工具类 * @since 2023-03-11 14:22 */ public class TreeUtil { /*** * 构建树 * * @param listData 需要构建的结果集 * @param parentKeyFunction 父节点id * @param keyFunction 主键 * @param setChildrenFunction 子集 * @param rootParentValue 父节点的值 0就填0 null就填null * @return java.util.List\u003cT\u003e */ public static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue) { return buildTree(listData, parentKeyFunction, keyFunction, setChildrenFunction, rootParentValue, null, null); } /*** * 构建树，并且对结果集做升序处理 * * @param listData 需要构建的结构集 * @param parentKeyFunction 父节点 * @param keyFunction 主键 * @param setChildrenFunction 子集 * @param rootParentValue 父节点的值 * @param sortFunction 排序字段 * @return java.util.List\u003cT\u003e */ public static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildAscTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue, Function\u003cT, ? extends Comparable\u003e sortFunction) { List\u003cT\u003e resultList = buildTree(listData, parentKeyFunction, keyFunction, setChildrenFunction, rootParentValue, sortFunction, 0); return sortList(resultList, sortFunction, 0); } /*** * 构建树，并且对结果集做降序处理 * * @param listData 需要构建的结构集 * @param parentKeyFunction 父节点 * @param keyFunction 主键 * @param setChildrenFunction 子集 * @param rootParentValue 父节点的值 * @param sortFunction 排序字段 * @return java.util.List\u003cT\u003e */ public static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildDescTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue, Function\u003cT, ? extends Comparable\u003e sortFunction) { List\u003cT\u003e resultList = buildTree(listData, parentKeyFunction, keyFunction, setChildrenFunction, rootParentValue, sortFunction, 1); return sortList(resultList, sortFunction, 1); } private static \u003cT, U extends Comparable\u003e List\u003cT\u003e buildTree(List\u003cT\u003e listData, Function\u003cT, U\u003e parentKeyFunction, Function\u003cT, ? extends Comparable\u003e keyFunction, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, U rootParentValue, Function\u003cT, ? extends Comparable\u003e sortFunction, Integer sortedFlag) { // 筛选出根节点 Map\u003cComparable, T\u003e rootKeyMap = new HashMap\u003c\u003e(); // 所有的节点 Map\u003cComparable, T\u003e allKeyMap = new HashMap\u003c\u003e(); // 存id:List\u003cChildrenId\u003e Map\u003cComparable, List\u003cComparable\u003e\u003e keyParentKeyMap = new HashMap\u003c\u003e(); for (T t : listData) { Comparable key = keyFunction.apply(t); Comparable parentKey = parentKeyFunction.apply(t); // 如果根节点标识为null，值也为null，表示为根节点 if (rootParentValue == null \u0026\u0026 parentKeyFunction.apply(t) == null) { rootKeyMap.put(key, t); } // 根节点标识有值，值相同表示为根节点 if (rootParentValue != null \u0026\u0026 parentKeyFunction.apply(t).compareTo(rootParentValue) == 0) { rootKeyMap.put(key, t); } allKeyMap.put(key, t); if (parentKey != null) { List\u003cComparable\u003e children = keyParentKeyMap.getOrDefault(parentKey, new ArrayList\u003c\u003e()); children.add(key); keyParentKeyMap.put(parentKey, children); } } List\u003cT\u003e returnList = new ArrayList\u003c\u003e(); // 封装根节点数据 for (Comparable comparable : rootKeyMap.keySet()) { setChildren(comparable, returnList, allKeyMap, keyParentKeyMap, setChildrenFunction, sortFunction, sortedFlag); } return returnList; } private static \u003cT\u003e void setChildren(Comparable comparable, List\u003cT\u003e childrenList, Map\u003cComparable, T\u003e childrenKeyMap, Map\u003cComparable, List\u003cComparable\u003e\u003e keyParentKeyMap, BiConsumer\u003cT, List\u003cT\u003e\u003e setChildrenFunction, Function\u003cT, ? extends Comparable\u003e sortFunction, Integer sortedFlag) { T t = childrenKeyMap.get(comparable); if (keyParentKeyMap.containsKey(comparable)) { List\u003cT\u003e subChildrenList = new ArrayList\u003c\u003e(); List\u003cComparable\u003e childrenComparable = keyParentKeyMap.get(comparable); for (Comparable c : childrenComparable","date":"2023-03-10","objectID":"/tree/:0:2","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["java"],"content":"使用 @Override public List\u003cMenu\u003e treeMenu(List\u003cMenu\u003e menuList) { /* * 构建树 * * @param listData 需要构建的结果集 这里是menuList * @param parentKeyFunction 父节点 这里是parentId * @param keyFunction 主键 这里是id * @param setChildrenFunction 子集 这里是children * @param rootParentValue 父节点的值 这里null * @return java.util.List\u003cT\u003e */ return TreeUtil.buildTree(menuList, Menu::getParentId, Menu::getId, Menu::setChildren, null); } ","date":"2023-03-10","objectID":"/tree/:0:3","tags":["tree"],"title":"java中通用树状菜单工具类","uri":"/tree/"},{"categories":["基础"],"content":"新的篇章，新的开始 经历了国内云服务器被封导致以前的博客全部丢失，现在转战静态博客，部署github上 ","date":"2023-03-09","objectID":"/first/:0:0","tags":["基础"],"title":"开篇!","uri":"/first/"}]